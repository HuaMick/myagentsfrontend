import 'package:flutter_test/flutter_test.dart';
import 'package:myagents_frontend/core/crypto/key_pair.dart';
import 'package:myagents_frontend/core/crypto/nacl_crypto.dart';

void main() {
  group('Python PyNaCl â†’ Dart pinenacl Interoperability', () {
    // Test vectors generated by PyNaCl (Python)
    // These keys remain the same across all test cases
    const alicePrivateKeyB64 = 'dL7U7Kx1/9tgFHziHd9jOY17Qk84aPQeqJnBKPg/mh0=';
    const alicePublicKeyB64 = '9fNbrP3VSw1CSj1r6BbeN85NjVCrM4HW4Y+PmwnmxQI=';
    const bobPrivateKeyB64 = 't9s06qtsHQ6cOeaD7JFp3y5StaTij3npU6yM2SupOCI=';
    const bobPublicKeyB64 = '7l1ZvIHFH86JTg5iOZ0voiaYN5yiXyha25FK6d+rMTY=';

    late KeyPair aliceKeys;
    late KeyPair bobKeys;

    setUp(() {
      // Import keys generated by Python
      aliceKeys = KeyPair.fromBase64({
        'privateKey': alicePrivateKeyB64,
        'publicKey': alicePublicKeyB64,
      });
      bobKeys = KeyPair.fromBase64({
        'privateKey': bobPrivateKeyB64,
        'publicKey': bobPublicKeyB64,
      });
    });

    test('Decrypt simple ASCII message encrypted by Python', () {
      // Python encrypted "Hello from Python!" using Alice's keys to Bob
      const pythonCiphertext = 'K5plRsDtGFIWp1cDAD57kk/fiTy/iJIuiYE5pJYtzEiRJ5ZQiybr2SE8HpZiq+aVBciAuIVGRaUDiw==';
      const expectedPlaintext = 'Hello from Python!';

      // Bob decrypts using his private key and Alice's public key
      final decrypted = NaClCrypto.decrypt(
        pythonCiphertext,
        bobKeys, // Our keys (Bob)
        aliceKeys, // Sender keys (Alice)
      );

      expect(decrypted, equals(expectedPlaintext));
    });

    test('Decrypt Unicode emoji message encrypted by Python', () {
      // Python encrypted "Python ðŸ â†’ Dart ðŸŽ¯" using Alice's keys to Bob
      const pythonCiphertext = 'WHlgM9SAu3euhVAz9ruHtDjMdUH7Wa99laMeLImG9PD8SLQIhxg17VJrrPW6yXU6dEv2RMh8HpZDF0wzuHxg/h4=';
      const expectedPlaintext = 'Python ðŸ â†’ Dart ðŸŽ¯';

      // Bob decrypts using his private key and Alice's public key
      final decrypted = NaClCrypto.decrypt(
        pythonCiphertext,
        bobKeys, // Our keys (Bob)
        aliceKeys, // Sender keys (Alice)
      );

      expect(decrypted, equals(expectedPlaintext));
    });

    test('Decrypt JSON payload encrypted by Python', () {
      // Python encrypted {"from": "python", "to": "dart"} using Alice's keys to Bob
      const pythonCiphertext = 'OHjmbQ3pas5wR6gziDt9q7trcdGzp+kqFz2zixFf75ZS3H8YtsgwZWzkbjLWaDkjHCNgnpdxE98amAzWyFsVlFSEwwZD4ITJ';
      const expectedPlaintext = '{"from": "python", "to": "dart"}';

      // Bob decrypts using his private key and Alice's public key
      final decrypted = NaClCrypto.decrypt(
        pythonCiphertext,
        bobKeys, // Our keys (Bob)
        aliceKeys, // Sender keys (Alice)
      );

      expect(decrypted, equals(expectedPlaintext));
    });

    test('Verify all test vectors use same key pair', () {
      // This test confirms that the Python script reused the same keys
      // across all three encryptions (important for test validity)
      expect(alicePublicKeyB64, equals('9fNbrP3VSw1CSj1r6BbeN85NjVCrM4HW4Y+PmwnmxQI='));
      expect(bobPublicKeyB64, equals('7l1ZvIHFH86JTg5iOZ0voiaYN5yiXyha25FK6d+rMTY='));
    });

    test('Verify nonce extraction from PyNaCl format', () {
      // PyNaCl's Box.encrypt() returns: nonce (24 bytes) || ciphertext
      // This test verifies our decrypt() correctly splits the format
      const pythonCiphertext = 'K5plRsDtGFIWp1cDAD57kk/fiTy/iJIuiYE5pJYtzEiRJ5ZQiybr2SE8HpZiq+aVBciAuIVGRaUDiw==';

      // Should not throw - if nonce extraction is wrong, decryption will fail
      expect(
        () => NaClCrypto.decrypt(pythonCiphertext, bobKeys, aliceKeys),
        returnsNormally,
      );
    });
  });

  group('PyNaCl Interop Edge Cases', () {
    test('Reject ciphertext too short (corrupted data)', () {
      const alicePrivateKeyB64 = 'dL7U7Kx1/9tgFHziHd9jOY17Qk84aPQeqJnBKPg/mh0=';
      const alicePublicKeyB64 = '9fNbrP3VSw1CSj1r6BbeN85NjVCrM4HW4Y+PmwnmxQI=';
      const bobPrivateKeyB64 = 't9s06qtsHQ6cOeaD7JFp3y5StaTij3npU6yM2SupOCI=';
      const bobPublicKeyB64 = '7l1ZvIHFH86JTg5iOZ0voiaYN5yiXyha25FK6d+rMTY=';

      final aliceKeys = KeyPair.fromBase64({
        'privateKey': alicePrivateKeyB64,
        'publicKey': alicePublicKeyB64,
      });
      final bobKeys = KeyPair.fromBase64({
        'privateKey': bobPrivateKeyB64,
        'publicKey': bobPublicKeyB64,
      });

      // Ciphertext must be at least 40 bytes: nonce (24) + MAC (16)
      const tooShortCiphertext = 'AAAAAAAAAAAAAAAAAAAAAA=='; // Only 16 bytes

      expect(
        () => NaClCrypto.decrypt(tooShortCiphertext, bobKeys, aliceKeys),
        throwsA(isA<ArgumentError>()),
      );
    });

    test('Reject tampered ciphertext (MAC verification)', () {
      const alicePrivateKeyB64 = 'dL7U7Kx1/9tgFHziHd9jOY17Qk84aPQeqJnBKPg/mh0=';
      const alicePublicKeyB64 = '9fNbrP3VSw1CSj1r6BbeN85NjVCrM4HW4Y+PmwnmxQI=';
      const bobPrivateKeyB64 = 't9s06qtsHQ6cOeaD7JFp3y5StaTij3npU6yM2SupOCI=';
      const bobPublicKeyB64 = '7l1ZvIHFH86JTg5iOZ0voiaYN5yiXyha25FK6d+rMTY=';

      final aliceKeys = KeyPair.fromBase64({
        'privateKey': alicePrivateKeyB64,
        'publicKey': alicePublicKeyB64,
      });
      final bobKeys = KeyPair.fromBase64({
        'privateKey': bobPrivateKeyB64,
        'publicKey': bobPublicKeyB64,
      });

      // Take valid ciphertext and corrupt the last byte (MAC corruption)
      const validCiphertext = 'K5plRsDtGFIWp1cDAD57kk/fiTy/iJIuiYE5pJYtzEiRJ5ZQiybr2SE8HpZiq+aVBciAuIVGRaUDiw==';
      const tamperedCiphertext = 'K5plRsDtGFIWp1cDAD57kk/fiTy/iJIuiYE5pJYtzEiRJ5ZQiybr2SE8HpZiq+aVBciAuIVGRaUDjw=='; // Changed last byte

      expect(
        () => NaClCrypto.decrypt(tamperedCiphertext, bobKeys, aliceKeys),
        throwsA(isA<CryptoException>()),
      );
    });
  });
}
